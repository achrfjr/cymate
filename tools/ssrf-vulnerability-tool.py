import requests
import urllib.parse
import sys
import argparse
import json
from requests.exceptions import RequestException, HTTPError, ConnectionError, Timeout

def is_valid_url(url):
    """Validate if the input is a proper URL."""
    try:
        result = urllib.parse.urlparse(url)
        return all([result.scheme, result.netloc]) and result.scheme in ['http', 'https']
    except ValueError:
        return False

def make_request(url, timeout=5):
    """Attempt to make an HTTP request to the provided URL with error handling."""
    result = {
        "url": url,
        "success": False,
        "status_code": None,
        "headers": {},
        "content_snippet": "",
        "errors": [],
        "warnings": []
    }
    
    try:
        # Simulate a server making a request with a custom User-Agent
        headers = {'User-Agent': 'SSRF-Test-Tool/1.0'}
        response = requests.get(url, headers=headers, timeout=timeout, allow_redirects=False)
        response.raise_for_status()  # Raise an exception for bad status codes
        
        # Update result for JSON
        result["success"] = True
        result["status_code"] = response.status_code
        result["headers"] = dict(response.headers)
        result["content_snippet"] = response.text[:500]
        
        # Check for potential SSRF indicators
        if 'localhost' in url.lower() or '127.0.0.1' in url:
            warning = "Request to localhost detected. Potential SSRF to internal systems!"
            result["warnings"].append(warning)
        if response.headers.get('Server'):
            warning = f"Server Info Leaked: {response.headers.get('Server')}"
            result["warnings"].append(warning)
        
        return True, result
    
    except ConnectionError:
        error = "Failed to connect to the server. The host may be unreachable."
        result["errors"].append(error)
        return False, result
    except Timeout:
        error = "The request timed out."
        result["errors"].append(error)
        return False, result
    except HTTPError as e:
        error = f"HTTP Error: {e.response.status_code} - {e.response.reason}"
        result["errors"].append(error)
        if e.response.status_code == 403:
            result["errors"].append("Access forbidden. This may indicate restricted access or a protected resource.")
        result["status_code"] = e.response.status_code
        return False, result
    except RequestException as e:
        error = f"Request Error: {str(e)}"
        result["errors"].append(error)
        return False, result

def main():
    """Main function to run the SSRF testing tool."""
    parser = argparse.ArgumentParser(
        description="SSRF Vulnerability Testing Tool: Tests for SSRF by making HTTP requests to a provided URL.",
        epilog="Use responsibly and only on systems you have permission to test."
    )
    parser.add_argument(
        "url",
        type=str,
        help="The URL to test (e.g., http://example.com)"
    )
    
    try:
        args = parser.parse_args()
        url = args.url.strip()
        
        # Validate URL
        if not url:
            print(json.dumps({"success": False, "error": "No URL provided."}))
            return
        if not is_valid_url(url):
            print(json.dumps({"success": False, "error": "Invalid URL. Ensure it includes http:// or https:// and a valid domain."}))
            return
        
        success, result = make_request(url)
        
        # Save result to JSON file
        try:
            with open("ssrf_test_result.json", "w") as f:
                json.dump(result, f, indent=4)
        except Exception as e:
            print(json.dumps({"success": False, "error": f"Error saving JSON result: {str(e)}"}), file=sys.stderr)
        
        # Print only the JSON result to stdout
        print(json.dumps(result, indent=4))
    except KeyboardInterrupt:
        print(json.dumps({"success": False, "error": "Operation cancelled by user."}))
        sys.exit(1)
    except Exception as e:
        print(json.dumps({"success": False, "error": f"Unexpected Error: {str(e)}"}))
        sys.exit(1)

if __name__ == "__main__":
    main()